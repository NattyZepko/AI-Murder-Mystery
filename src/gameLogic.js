const readline = require('readline');
const { generateScenario } = require('./scenarioGenerator');
const { debugScenario } = require('./debug');
const { chatWithAI } = require('./ai');
const { logUser, logAI } = require('./logger');
const { COLOR, clearScreen } = require('./ui');
const { createSuspectInteractor } = require('./suspectInteraction');
const { KEYS, TEXT } = require('./constants');
const { exit } = require('process');
const { applyScenarioRules } = require('./scenarioRules');

async function startGame() {
    // Scenario can be async if generated by AI
    let scenario;
    const maybePromise = generateScenario();
    if (typeof maybePromise?.then === 'function') {
        // async path
        // show a tiny loading notice; keep it simple
        clearScreen();
        console.log(TEXT.APP.GENERATING_CASE);
        scenario = await maybePromise;
    } else {
        scenario = maybePromise;
    }

    // Apply normalization/rules (alibis symmetry, motives, weapon proximity, shared story, gender/age)
    try {
        scenario = applyScenarioRules(scenario || {});
    } catch (_) {
        // If rules fail for any reason, keep original scenario
    }

    const rl = readline.createInterface({
        input: process.stdin,
        output: process.stdout
    });

    // Helpers
    const ask = (q) => new Promise(resolve => rl.question(q, a => resolve(a)));
    async function waitForEnter(promptText) {
        await ask(promptText);
    }
    async function promptNumber(promptText, min, max) {
        const answer = await ask(promptText);
        const trimmed = String(answer).trim().toLowerCase();
        if (trimmed === KEYS.BACK || trimmed === KEYS.BACK_SHORT) return null;
        const num = parseInt(trimmed, 10);
        if (!Number.isFinite(num) || num < min || num > max) {
            console.log(TEXT.COMMON.INVALID_OPTION);
            return await promptNumber(promptText, min, max);
        }
        return num;
    }

    // Input locking to prevent typing while AI is thinking
    let inputLockCount = 0;
    let swallowHandler = null;
    const lockInput = () => {
        if (!process.stdin.isTTY) return; // can't lock
        inputLockCount += 1;
        if (inputLockCount > 1) return; // already locked
        try { process.stdin.setRawMode(true); } catch (_) { /* ignore */ }
        swallowHandler = (chunk) => {
            // Allow Ctrl+C to exit cleanly while locked
            if (chunk && chunk[0] === 3) { // Ctrl+C
                try { process.exit(0); } catch (_) {}
            }
            // Swallow all other input while locked
        };
        process.stdin.on('data', swallowHandler);
    };
    const unlockInput = () => {
        if (!process.stdin.isTTY) return;
        inputLockCount = Math.max(0, inputLockCount - 1);
        if (inputLockCount > 0) return;
        if (swallowHandler) {
            process.stdin.off('data', swallowHandler);
            swallowHandler = null;
        }
        try { process.stdin.setRawMode(false); } catch (_) { /* ignore */ }
    };

    // Shuffle suspects to avoid predictable ordering
    function shuffleArray(arr) {
        const a = arr.slice();
        for (let i = a.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [a[i], a[j]] = [a[j], a[i]];
        }
        return a;
    }
    if (Array.isArray(scenario.suspects) && scenario.suspects.length > 1) {
        scenario.suspects = shuffleArray(scenario.suspects);
    }

    // Lightweight in-memory clue tracking
    const discoveredClues = [];
    const mentionedWeapons = new Set();

    console.log(TEXT.APP.WELCOME);
    console.log(`\n${TEXT.CASE.PREFIX}${scenario.title}`);
    console.log(`${TEXT.CASE.SETTING_PREFIX}${scenario.setting}`);
    if (scenario.victim?.name || scenario.victim?.timeOfDeath) {
        const vName = scenario.victim?.name ? `${TEXT.CASE.VICTIM_LABEL} ${scenario.victim.name}` : `${TEXT.CASE.VICTIM_LABEL} Unknown`;
        const vTime = scenario.victim?.timeOfDeath ? `${TEXT.CASE.TIME_OF_DEATH_PREFIX} ${scenario.victim.timeOfDeath}` : '';
        console.log(`${vName}${vTime ? ` | ${vTime}` : ''}`);
    }
    console.log('');

    function showMenu() {
        clearScreen();
        console.log(TEXT.MENU.TITLE);
        console.log(TEXT.MENU.INSTRUCTIONS);
        console.log(TEXT.MENU.SUSPECTS);
        console.log(TEXT.MENU.CLUES);
        console.log(TEXT.MENU.SUBMIT);
        console.log(TEXT.MENU.EXIT);
        console.log(TEXT.MENU.DEBUG);
        rl.question(TEXT.MENU.PROMPT_SELECT_OPTION, handleMenu);
    }

    function showInstructions() {
        // Don't clear hereâ€”so the intro remains visible on first run.
        console.log(`${TEXT.INSTRUCTIONS.TITLE}\n`);
        console.log(`${TEXT.INSTRUCTIONS.INTRO}\n`);
        try {
            console.log(`${TEXT.CASE.PREFIX}${scenario.title}`);
            console.log(`${TEXT.CASE.SETTING_PREFIX}${scenario.setting}`);
            if (scenario.victim) {
                const vName = scenario.victim?.name ? `${TEXT.CASE.VICTIM_LABEL} ${scenario.victim.name}` : `${TEXT.CASE.VICTIM_LABEL} Unknown`;
                const vTime = scenario.victim?.timeOfDeath ? `${TEXT.CASE.TIME_OF_DEATH_PREFIX} ${scenario.victim.timeOfDeath}` : '';
                console.log(`${vName}${vTime ? ` | ${vTime}` : ''}`);
            }
            console.log('');
        } catch (_) {}
        console.log(TEXT.INSTRUCTIONS.HOW_TO_PLAY);
        console.log(TEXT.INSTRUCTIONS.TIPS.ASK_QUESTIONS);
        console.log(TEXT.INSTRUCTIONS.TIPS.CLUE_LIST);
        console.log(TEXT.INSTRUCTIONS.TIPS.SUBMIT);
        console.log(`${TEXT.INSTRUCTIONS.TIPS.WIN}\n`);
        console.log(TEXT.INSTRUCTIONS.TIPS.TITLE);
        console.log(TEXT.INSTRUCTIONS.TIPS.CONTRADICTIONS);
        console.log(TEXT.INSTRUCTIONS.TIPS.RELEVANCE);
        console.log(TEXT.INSTRUCTIONS.TIPS.FOLLOWUPS);
        console.log(`${TEXT.INSTRUCTIONS.TIPS.BACK}\n`);
        rl.question(TEXT.COMMON.PROMPT_RETURN_MENU, () => {
            showMenu();
        });
    }

    function listSuspects() {
        clearScreen();
        console.log(TEXT.SUSPECTS.LIST_TITLE);
        scenario.suspects.forEach((suspect, index) => {
            const gender = suspect.gender || 'unknown';
            const age = (typeof suspect.age === 'number' && Number.isFinite(suspect.age)) ? suspect.age : 'N/A';
            console.log(`${index + 1}. ${suspect.name} (${gender}, ${age})`);
        });
    }

    function promptSelectSuspect() {
        rl.question(TEXT.SUSPECTS.PROMPT_SELECT, (answer) => {
            const raw = String(answer).trim();
            const trimmed = raw.toLowerCase();
            if (trimmed === KEYS.BACK_SHORT || trimmed === KEYS.BACK) {
                return showMenu();
            }
            const idx = parseInt(trimmed, 10);
            if (Number.isNaN(idx) || idx < 1 || idx > scenario.suspects.length) {
                // Try name match (case-insensitive exact)
                const byName = scenario.suspects.find(s => (s.name || '').toLowerCase() === trimmed);
                if (!byName) {
                    console.log(TEXT.SUSPECTS.INVALID_SELECTION);
                    return promptSelectSuspect();
                }
                return interactWithSuspect(byName).then(() => showMenu());
            }
            const suspect = scenario.suspects[idx - 1];
            interactWithSuspect(suspect).then(() => showMenu());
        });
    }

    const interactWithSuspect = createSuspectInteractor({ rl, scenario, lockInput, unlockInput, discoveredClues, mentionedWeapons, logUser, logAI, chatWithAI });

    function showClues() {
        clearScreen();
        console.log(`${TEXT.CLUES.LIST_TITLE}\n`);
        if (!discoveredClues.length) {
            console.log(`${TEXT.CLUES.NO_CLUES_YET}\n`);
        } else {
            // Helper to colorize names (red) and weapons (yellow) in text
            const suspectNames = (scenario.suspects || []).map(s => s.name).filter(Boolean);
            const weaponNames = (scenario.weapons || []).map(w => w.name).filter(Boolean);
            const escapeReg = (s) => s.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
            const colorizeText = (text) => {
                if (!text) return '';
                let out = String(text);
                // Highlight weapon names first (yellow)
                for (const wn of weaponNames) {
                    const re = new RegExp(escapeReg(wn), 'gi');
                    out = out.replace(re, (m) => `${COLOR.yellow}${m}${COLOR.reset}`);
                }
                // Then highlight suspect names (red)
                for (const sn of suspectNames) {
                    const re = new RegExp(escapeReg(sn), 'g');
                    out = out.replace(re, (m) => `${COLOR.red}${m}${COLOR.reset}`);
                }
                return out;
            };

            discoveredClues.forEach((c, i) => {
                const subjectColored = `${COLOR.red}${c.subject}${COLOR.reset}`;
                const noteColored = colorizeText(c.note);
                console.log(`${i + 1}. [${c.type}] ${subjectColored}: ${noteColored}`);
            });
            console.log('');
        }
        // Weapons mentioned so far
        try {
            const arr = Array.from(mentionedWeapons);
            console.log(TEXT.CLUES.WEAPONS_MENTIONED_TITLE);
            if (!arr.length) {
                console.log(`- ${TEXT.CLUES.NONE_YET}`);
            } else {
                arr.forEach(w => console.log(`- ${COLOR.yellow}${w}${COLOR.reset}`));
            }
            console.log('');
        } catch (_) {}
        rl.question(TEXT.COMMON.PROMPT_RETURN_MENU, () => {
            showMenu();
        });
    }

    async function submitConclusion() {
        clearScreen();
        console.log(TEXT.SUBMISSION.TITLE);

        const suspects = Array.isArray(scenario.suspects) ? scenario.suspects : [];
        if (!suspects.length) {
            console.log(TEXT.COMMON.INVALID_OPTION);
            return rl.question(TEXT.COMMON.PROMPT_RETURN_MENU, () => showMenu());
        }

        // Present numbered suspect list with gender/age
        suspects.forEach((s, idx) => {
            const gender = s.gender || 'unknown';
            const age = (typeof s.age === 'number' && Number.isFinite(s.age)) ? s.age : 'N/A';
            console.log(`${idx + 1}. ${s.name} (${gender}, ${age})`);
        });

        const suspectIdx = await promptNumber(TEXT.SUBMISSION.PROMPT_WHO_MURDERER, 1, suspects.length);
        if (suspectIdx == null) { return showMenu(); }
        const selectedSuspect = suspects[suspectIdx - 1];

        // Only list weapons that have been mentioned in clues (case-insensitive match)
        const allWeapons = Array.isArray(scenario.weapons) ? scenario.weapons : [];
        const mentioned = new Set(Array.from(mentionedWeapons).map(w => String(w).toLowerCase()));
        const revealedWeapons = allWeapons.filter(w => mentioned.has(String(w.name || '').toLowerCase()));

        if (revealedWeapons.length === 0) {
            console.log(TEXT.SUBMISSION.INSUFFICIENT_EVIDENCE);
            await waitForEnter(TEXT.COMMON.PROMPT_RETURN_MENU);
            return showMenu();
        }

        console.log(TEXT.CLUES.WEAPONS_MENTIONED_TITLE);
        revealedWeapons.forEach((w, idx) => {
            console.log(`${idx + 1}. ${w.name}`);
        });

        const weaponIdx = await promptNumber(TEXT.SUBMISSION.PROMPT_WHAT_WEAPON, 1, revealedWeapons.length);
        if (weaponIdx == null) { return showMenu(); }
        const selectedWeapon = revealedWeapons[weaponIdx - 1];

        const truthGuiltyId = scenario.truth?.guiltySuspectId || scenario.guiltySuspectId;
        const truthWeaponId = scenario.truth?.murderWeaponId || scenario.murderWeaponId;

        const isCorrectSuspect = truthGuiltyId ? (selectedSuspect.id === truthGuiltyId) : false;
        const isCorrectWeapon = truthWeaponId ? (selectedWeapon.id === truthWeaponId) : false;

        if (isCorrectSuspect && isCorrectWeapon) {
            console.log(`\n${TEXT.SUBMISSION.CORRECT_PREFIX} ${selectedSuspect.name} is the murderer and used the ${selectedWeapon.name}. Case closed!\nWe shall now reveal the truth...\n`);

            const revealSuspect = (scenario.suspects || []).find(s => s.id === truthGuiltyId);
            const revealWeapon = (scenario.weapons || []).find(w => w.id === truthWeaponId);

            if (revealSuspect && revealWeapon) {
                console.log(`${TEXT.SUBMISSION.TRUTH_PREFIX} ${revealSuspect.name} using the ${revealWeapon.name}.`);
            }

            if (scenario.truth?.motiveCore) {
                console.log(`${TEXT.SUBMISSION.MOTIVE_PREFIX} ${scenario.truth.motiveCore}`);
            } else if (revealSuspect?.motive) {
                console.log(`${TEXT.SUBMISSION.MOTIVE_PREFIX} ${revealSuspect.motive}`);
            }

            if (Array.isArray(scenario.truth?.keyContradictions) && scenario.truth.keyContradictions.length) {
                console.log(TEXT.SUBMISSION.KEY_CONTRADICTIONS_TITLE);
                scenario.truth.keyContradictions.forEach(k => console.log(`- ${k}`));
            }
            console.log('');
            exit();
            return;
        } else {
            console.log(`\n${TEXT.SUBMISSION.NOT_QUITE}\n`);
            return rl.question(TEXT.COMMON.PROMPT_RETURN_MENU, () => showMenu());
        }
    }

    function handleMenu(option) {
        switch (String(option).trim()) {
            case '1':
                showInstructions();
                break;
            case '2':
                listSuspects();
                promptSelectSuspect();
                break;
            case '3':
                showClues();
                break;
            case '4':
                submitConclusion();
                break;
            case '5':
                console.log(TEXT.COMMON.EXITING);
                rl.close();
                break;
            case '6':
                clearScreen();
                console.log(`${TEXT.DEBUG.TITLE}\n`);
                debugScenario(scenario);
                rl.question(`\n${TEXT.COMMON.PROMPT_RETURN_MENU}`, () => showMenu());
                break;
            default:
                console.log(`${TEXT.COMMON.INVALID_OPTION}\n`);
                showMenu();
        }
    }

    showInstructions();
}

module.exports = { startGame };